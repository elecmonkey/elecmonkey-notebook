# 第七章 内存管理 (Memory Management)

## 7.1 主内存基础 (Main Memory Fundamentals)

### 7.1.1 内存管理概述

#### 内存在计算机系统中的重要性
内存是现代计算机系统操作的核心组件。只有主内存和寄存器是CPU能够直接访问的存储器。程序必须从磁盘装入内存才能执行。

#### 指令执行周期 (Instruction-Execution Cycle)
1. **取指令 (Fetch)**：CPU根据程序计数器的值从内存中取出指令
2. **译码 (Decode)**：对指令进行译码，可能需要从内存中取操作数
3. **执行 (Execute)**：执行指令后，结果可能需要存回内存

#### 内存访问速度层次
- **寄存器访问**：一个CPU时钟周期
- **主内存访问**：多个CPU时钟周期  
- **缓存 (Cache)**：位于主内存和CPU寄存器之间，弥补速度差异

### 7.1.2 地址绑定与地址空间

#### 进程的正常执行过程
1. 磁盘上等待被载入内存执行的进程形成**输入队列 (Input Queue)**
2. 从输入队列中选择一个进程并载入内存
3. 进程从内存中访问指令和数据
4. 进程终止时，其内存空间被声明为可用

#### 地址表示的不同方式
- **符号地址 (Symbolic Address)**：源程序中的地址，如 `goto loop1`
- **可重定位地址 (Relocatable Address)**：编译器生成，如"距模块开始14字节"
- **绝对地址 (Absolute Address)**：链接编辑器或装载器生成，如 `0x0007 4014`

#### 地址绑定的三个阶段
1. **编译时绑定 (Compile Time)**
   - 内存位置在编译时已知
   - 生成绝对代码
   - 起始位置改变需要重新编译
   - 例：MS-DOS的.COM格式程序

2. **装载时绑定 (Load Time)**
   - 编译时内存位置未知，生成可重定位代码
   - 装载时生成绝对代码
   - 起始位置改变只需重新装载

3. **执行时绑定 (Execution Time)**
   - 编译和装载时内存位置都未知
   - 运行时才生成绝对代码
   - 进程执行期间可以在内存段间移动
   - 需要硬件支持地址映射（如基址和限长寄存器）

#### 逻辑地址与物理地址
- **物理地址 (Physical Address)**：内存单元看到的地址，直接装入内存地址寄存器
- **逻辑地址 (Logical Address)**：CPU生成的地址，也称为虚拟地址 (Virtual Address)

在编译时和装载时地址绑定方案中，逻辑地址和物理地址相同。在执行时地址绑定方案中，逻辑地址和物理地址不同。

#### 内存管理单元 (Memory-Management Unit, MMU)
MMU是将虚拟地址映射到物理地址的硬件设备。在简单的MMU方案中，重定位寄存器的值被加到用户进程生成的每个地址上。

### 7.1.3 内存保护机制

#### 保护需求
- 保护操作系统免受用户进程访问
- 保护用户进程彼此间免受影响
- 确保每个进程有独立的内存空间
- 确定进程合法地址范围
- 确保进程只能访问合法地址

#### 基址和限长寄存器 (Base and Limit Registers)
- **基址寄存器 (Base Register)**：包含最小的合法物理内存地址
- **限长寄存器 (Limit Register)**：指定地址范围的大小
- CPU硬件将用户模式下生成的每个地址与这些寄存器进行比较

### 7.1.4 动态加载与链接

#### 动态加载 (Dynamic Loading)
- 程序和数据是否需要全部在物理内存中才能执行？
- **原理**：例程在被调用时才被装载
- **优势**：更好的内存空间利用率，未使用的例程永远不被装载
- **适用场景**：需要大量代码处理不常发生情况时，如错误处理例程
- **系统支持**：操作系统提供库例程帮助程序员实现动态加载

#### 静态链接 vs 动态链接

**静态链接 (Static Linking)**
- 系统语言库被当作其他目标模块处理
- 由装载器合并到二进制程序映像中
- 每个程序必须在可执行映像中包含语言库的副本
- 浪费磁盘空间和主内存

**动态链接 (Dynamic Linking)**
- 链接推迟到执行时
- **存根 (Stub)**：小段代码，包含在每个库例程引用的映像中
- 存根用于定位相应的内存驻留库例程，或在例程不存在时装载库
- 执行存根时，操作系统检查例程是否在进程内存地址中，用例程地址替换存根并执行
- **优势**：库更新时，所有引用它的程序自动使用新版本

## 7.2 连续内存分配 (Contiguous Memory Allocation)

### 7.2.1 交换技术 (Swapping)

#### 交换的基本概念
交换是将进程临时从内存换出到后备存储器 (Backing Store)，然后再调回内存继续执行的技术。

#### 交换的应用场景
1. **多道程序环境中的时间片轮转**
   - 时间片到期时，内存管理器换出正在运行的进程
   - 将另一个进程换入该内存空间

2. **基于优先级的调度算法中的换入换出 (Roll In, Roll Out)**
   - 低优先级进程被换出，高优先级进程被装载和执行
   - 高优先级进程结束后，低优先级进程被换回

#### 后备存储器 (Backing Store)
- 快速磁盘，足够大以容纳所有用户的内存映像副本
- 必须提供对这些内存映像的直接访问

#### 就绪队列 (Ready Queue)
由所有内存映像在后备存储器或内存中且准备运行的进程组成。

#### 交换时间考虑
- **上下文切换时间**：换出、换入
- **主要时间**：传输时间（假设无寻道时间）
- 总传输时间与交换的内存量直接成比例
- 例：进程大小10MB，磁盘传输速度40MB/s，传输时间 = 10/40 = 0.25秒 = 250ms

### 7.2.2 连续内存分配类型

#### 内存划分
主内存通常分为两个分区：
1. **常驻操作系统**：通常在低地址内存，带有中断向量
2. **用户进程**：在高地址内存

#### 固定分区 (Fixed-Sized Contiguous Partition)
**基本思想**：系统生成时将内存分为若干个固定大小的分区

**特点**：
- 等大小分区或不等大小分区
- 每个分区恰好包含一个进程
- 多道程序度受分区数量限制

**优点**：
- 实现简单
- 开销小

**缺点**：
- 内部碎片（分配的内存可能大于请求的内存）
- 进程数量固定

#### 可变分区 (Dynamic Contiguous Partition)
**基本思想**：动态创建分区，每个进程载入到与其大小完全相同的分区中

**空闲块 (Hole)**：可用内存块
- 初始时，所有内存都可用，被视为一个大空闲块
- 进程到达时，从空闲块中分配恰好容纳它的内存，剩余部分形成更小的空闲块

### 7.2.3 内存分配算法

#### 首次适应 (First-Fit)
- 分配第一个足够大的空闲块
- 搜索可以从空闲块集合的开始处开始，或从上次首次适应搜索结束的地方开始

#### 最佳适应 (Best-Fit)
- 分配足够大的最小空闲块
- 需要搜索整个列表，除非列表按大小排序
- 产生最小的剩余空闲块

#### 最坏适应 (Worst-Fit)
- 分配最大的空闲块
- 需要搜索整个列表，除非列表按大小排序
- 产生最大的剩余空闲块

**性能比较**：首次适应和最佳适应在分配速度和存储利用率方面优于最坏适应。

### 7.2.4 碎片问题及解决方案

#### 外部碎片 (External Fragmentation)
- 随着进程装载和移除，空闲内存空间被分割成大量小空闲块
- 总内存空间足够满足请求，但不连续
- **50%规则**：对于首次适应算法，给定N个已分配块，平均有0.5N个块因碎片而丢失

#### 内部碎片 (Internal Fragmentation)
- 分配的内存可能比请求的内存稍大
- 例：18,464字节的空闲块，进程请求18,400字节，剩余64字节
- 管理64字节空闲块的开销可能大于空闲块本身
- 64字节被分配给进程，形成内部碎片

#### 解决方案

1. **紧凑 (Compaction)**
   - 减少外部碎片
   - 移动内存内容，将所有空闲内存放在一个大块中
   - 只有当重定位是动态的时才可能
   - 移动进程和空闲块的成本可能很高

2. **分页 (Paging) 和分段 (Segmentation)**
   - 外部碎片问题的另一种解决方案

## 7.3 分页机制 (Paging System)

### 7.3.1 分页基本概念

#### 分页的优势
分页是一种重要的内存管理方案，允许进程的物理地址空间是非连续的，避免了连续内存分配的缺点。

#### 基本方法
- **帧 (Frame)**：将物理内存分为固定大小的块
- **页 (Page)**：将逻辑内存分为相同大小的块
- 页的大小等于帧的大小
- 为装载n页大小的程序找到n个空闲帧

#### 地址转换
CPU生成的每个逻辑地址分为：
- **页号 (Page Number, p)**：用作页表的索引，页表包含每页在物理内存中的基址
- **页偏移 (Page Offset, d)**：与基址结合定义发送到内存单元的物理内存地址

物理地址包含：
- **帧号 (Frame Number, f)**：从页表中获得
- **页偏移 (Page Offset, d)**：与逻辑地址中的相同

### 7.3.2 分页的特点

#### 碎片问题
- **无外部碎片**：分页方案不存在外部碎片
- **内部碎片**：可能存在，最后一帧可能不完全填满
- 平均每个进程的内部碎片为半页

#### 页大小选择考虑因素
1. **内部碎片**：小页大小更理想
2. **页表大小**：页大小增加时，每个页表项的开销减少
3. **磁盘I/O**：页大小较大时磁盘I/O更高效

#### 物理内存管理
- 通常每个页表项为4字节长
- 可以指向2^32个物理页帧中的一个
- 如果帧大小（=页大小）为4KB，系统可以寻址2^44字节（16TB）的物理内存

### 7.3.3 页表实现

#### 寄存器实现
- 页表保存在快速寄存器中（页表较小时，如少于256项）
- 高效但昂贵
- 例：DEC PDP-11

#### 内存实现
- 页表保存在主内存中
- **页表基址寄存器 (Page-Table Base Register, PTBR)**：指向页表
- 进程切换时，只需改变PTBR，大大减少上下文切换时间
- **缺点**：每个数据/指令访问需要两次内存访问

#### TLB (Translation Look-aside Buffer)
- **联想寄存器**：特殊的快速查找硬件缓存
- 只包含少数页表项
- TLB支持并行搜索

**TLB工作机制**：
1. 如果逻辑地址的页号p在TLB中找到，立即获得帧号f并访问内存
2. 如果页号p在TLB中未找到（TLB失效），从内存中的页表获得帧号，并将页号和帧号添加到TLB
3. 如果TLB已满，需要某种置换机制

#### 地址空间标识符 (Address-Space Identifiers, ASIDs)
一些TLB在每个TLB项中存储地址空间标识符：
- TLB可以同时包含多个不同进程的项
- ASID唯一标识每个进程，为该进程提供地址空间保护
- 如果TLB不支持单独的ASID，选择新页表时必须刷新TLB

#### 有效访问时间计算
命中率 = 0.8，有效访问时间 = 0.80×120 + 0.20×220 = 140 ns
命中率 = 0.98，有效访问时间 = 0.98×120 + 0.02×220 = 122 ns

### 7.3.4 内存保护与共享

#### 内存保护
通过将保护位与每帧关联来实现：
- 读写或只读或只执行
- 非法访问将被捕获到操作系统

#### 有效-无效位 (Valid-Invalid Bit)
附加到页表中的每个项：
- **有效 (Valid)**：表示关联页在进程的逻辑地址空间中，是合法页
- **无效 (Invalid)**：表示页不在进程的逻辑地址空间中

#### 共享页面
**共享代码**：
- 只读（可重入）代码的一个副本在进程间共享
- 共享代码必须出现在所有进程逻辑地址空间的相同位置

**私有代码和数据**：
- 每个进程保持代码和数据的单独副本
- 私有代码和数据的页面可以出现在逻辑地址空间的任何地方

**共享示例**：在分时环境中，40个用户执行文本编辑器。一个文本编辑器进程包含150KB代码和50KB数据。
- 无共享：(150KB + 50KB)×40 = 8000KB
- 有共享：50KB×40 + 150KB = 2150KB

## 7.4 虚拟内存 (Virtual Memory)

### 7.4.1 虚拟内存概念与优势

#### 传统内存管理的局限性
传统内存管理方法往往要求整个进程在执行前都在内存中。然而，在许多情况下：
- 程序经常有处理异常错误条件的代码
- 数组、列表和表通常分配比实际需要更多的内存
- 程序的某些选项和功能很少使用

#### 虚拟内存的基本思想
**虚拟内存管理 (Virtual Memory Management)** 是一种技术，使计算机看起来拥有比实际更多的内存。

**核心原理**：
- 只有部分程序需要在内存中执行
- 逻辑地址空间可以比物理地址空间大得多

#### 虚拟内存的优势
1. **程序不再受物理内存数量限制**
2. **更多程序可以同时运行**
3. **装载或交换每个用户程序需要更少的I/O，程序启动更快**

#### 虚拟地址空间 (Virtual Address Space)
指进程如何存储在内存中的逻辑视图：
- 包括空洞，称为稀疏地址空间 (Sparse Address Spaces)
- 允许更高效的进程创建
- 允许页面共享，加速进程创建
- 允许地址空间被多个进程共享

#### 虚拟内存实现方式
- **请求分页 (Demand Paging)**
- **请求分段 (Demand Segmentation)**

### 7.4.2 请求分页 (Demand Paging)

#### 基本概念
请求分页是虚拟内存系统中常用的技术，只在需要时将页面带入内存。

**惰性交换器 (Lazy Swapper)**：
- 传统交换器：想要执行进程时，将其（整个进程）交换到内存中
- **惰性分页器 (Lazy Pager)**：将进程视为页面序列，只将必要的页面带入内存

#### 请求分页的硬件支持
1. **页表**：每个页表项关联一个有效-无效位
   - v：页面是合法的并在内存中
   - i：页面是非法的或不在内存中

2. **辅助内存**：高速磁盘，称为交换空间，保存不在内存中的页面

#### 页错误 (Page Fault)
访问标记为无效的页面会导致页错误陷阱。分页硬件在通过页表转换地址时，发现有效-无效位为0，引起操作系统陷阱。

#### 页错误处理步骤
1. 操作系统查看另一个表（PCB）确定：
   - 无效引用 → 中止
   - 只是不在内存中 → 继续第2步
2. 获取空闲帧
3. 将所需页面交换到帧中
4. 修改页表，设置有效位 = v
5. 重新启动引起页错误的指令

#### 纯请求分页 (Pure Demand Paging)
以没有页面在内存中的状态开始执行进程，直到需要时才将页面带入内存。

#### 指令重新执行 (Restart Instruction)
页错误可能在任何内存引用时发生。中断进程的状态（寄存器、条件代码、指令计数器）被保存，需要在页错误后重新启动指令。

**最坏情况示例**：`*C = *A + *B;`
1. 取指令并译码
2. 取A
3. 取B  
4. A和B相加
5. 将和存储在C中

如果在存储到C时发生页错误，获取所需页面后必须重新开始整个指令。

#### 请求分页的性能
**有效访问时间 (Effective Access Time, EAT)**：
- 设p为页错误概率（0 ≤ p ≤ 1）
- EAT = (1-p) × (内存访问时间) + p × (页错误时间)
- 如果p = 0，无页错误
- 如果p = 1，每次引用都是错误
- 大多数时候，p非常接近0

### 7.4.3 写时复制 (Copy-on-Write)

#### 概念
写时复制 (COW) 允许父进程和子进程最初共享内存中的相同页面。这些共享页面被标记为写时复制页面。

#### 工作机制
- **fork()** 时，父进程和子进程共享相同页面
- 如果任一进程修改共享页面，就创建该共享页面的副本
- 提供快速进程创建并最小化新页面的数量

#### vfork()
- 父进程被挂起，子进程使用父进程的地址空间
- 如果子进程改变父进程地址空间的任何页面，父进程恢复后可以看到改变的页面
- 非常高效但危险
- 适用于子进程创建后立即调用exec()的情况

### 7.4.4 页面置换算法

#### 页面置换的必要性
当没有空闲帧时会发生什么？
- 假设有40帧，一个10页的进程实际只使用5页，可以运行8个进程而不是4个
- 如果增加多道程序度，会过度分配内存
- 如果运行6个进程，需要60帧，但只有40帧可用

#### 页面置换的选择
1. **终止用户进程**
2. **交换出一个进程**，释放其所有帧，降低多道程序度
3. **执行页面置换**

#### 基本页面置换流程
1. 在磁盘上找到所需页面的位置
2. 找到空闲帧：
   - 如果有空闲帧，使用它
   - 如果没有空闲帧，使用页面置换算法选择牺牲帧
3. 将所需页面读入新空闲的帧，更新页表和帧表
4. 重新启动进程

#### 修改位 (Modify Bit) 的优化
- 每个页面或帧可能有一个硬件相关的修改位（脏位）
- 页面中的任何字或字节被写入时设置修改位
- 如果已修改，页面换出和页面换入
- 如果干净，只需页面换入

#### 主要页面置换算法

##### 1. 先进先出 (FIFO) 算法
**原理**：记录页面带入内存的时间，必要时置换最老的页面

**实现**：使用FIFO队列保存内存中的所有页面，在队列头部置换页面，页面带入内存时加到队列尾部

**特点**：
- 易于理解和实现
- 性能不总是好的
- 可能出现Belady异常（更多帧导致更多页错误）

##### 2. 最优 (OPT) 算法
**原理**：置换最长时间不会被使用的页面

**特点**：
- 最低页错误率
- 无Belady异常
- 难以实现（需要预知未来）
- 可用于比较研究

##### 3. 最近最少使用 (LRU) 算法
**原理**：记录页面最后使用的时间，置换最长时间未被使用的页面

**基本思想**：用最近的过去近似最近的将来

**实现方法**：
1. **计数器**：每个页表项有计数器，页面被引用时将时钟复制到计数器
2. **栈**：用双链表形式保存页号栈，页面被引用时移到栈顶

**特点**：
- 无Belady异常
- 无额外硬件支持时，计数器和栈都不可能实现

##### 4. LRU近似算法

**引用位 (Reference Bit)**：
- 与页表中每个项关联的引用位，初始为0
- 页面被引用时硬件将引用位设为1

**附加引用位算法**：
- 为每个页面在内存中保留8位字节
- 定期（每100ms），定时器中断时操作系统：
  - 将引用位移入8位字节的高位
  - 其他位右移1位
  - 丢弃低位
- 这些8位字节包含最近8个时间段的页面使用历史

**二次机会 (Second Chance) 算法**：
- 检查页面的引用位
- 如果值为0，置换它
- 如果值为1，设引用位为0，给它第二次机会，尝试下一个
- 实现：页面的循环队列

## 7.5 高级内存管理

### 7.5.1 帧分配策略

#### 最小帧数
必须有足够的帧来保存任何单个指令可能引用的所有不同页面，由体系结构定义：
- PDP-11：2页
- IBM 370的MVC：6页或8页（最坏情况）

#### 最大帧数
由可用物理内存数量定义。

#### 分配方案

##### 固定分配
1. **等分分配**：例如，100帧和5个进程，每个进程分配20帧
2. **比例分配**：根据进程大小分配
   - 公式：a_i = (s_i/S) × m
   - 其中 s_i 是进程 i 的大小，S 是所有进程大小之和，m 是帧总数

##### 优先级分配
使用基于优先级而不是大小的比例分配方案。

#### 全局置换 vs 局部置换

**局部置换 (Local Replacement)**：
- 进程只能从自己分配的帧集合中选择置换帧
- 不能增加分配的帧数
- 不受外部环境影响

**全局置换 (Global Replacement)**：
- 进程可以从所有帧的集合中选择置换帧，即使该帧当前分配给其他进程
- 可以增加分配的帧数
- 更大的系统吞吐量
- 无法控制页错误率
- 受外部环境影响
- 一般来说，全局置换更好

### 7.5.2 抖动现象与防护

#### 抖动的定义
如果进程花在分页上的时间多于执行时间，该进程就在**抖动 (Thrashing)**。

#### 抖动的原因
- 如果进程没有"足够"的页面，它会很快发生页错误
- 必须置换一些页面，但被置换的页面正在使用中，可能立即被调回
- 页错误率非常高，导致抖动

#### 抖动产生的过程
1. CPU利用率低时，操作系统引入新进程增加多道程序度
2. 新进程会从其他进程夺取帧（通过全局置换）
3. 但这些进程也需要那些页面，也会发生错误
4. 进程排队等待分页设备，分页设备忙于页面换入换出
5. CPU利用率下降 → 抖动

#### 防止抖动的方法

##### 1. 局部置换算法
- 如果一个进程开始抖动，它不能从其他进程偷取帧
- 但问题没有完全解决，抖动进程忙于换入换出会增加页错误的平均时间

##### 2. 工作集策略 (Working-Set Strategy)

**局部性模型 (Locality Model)**：
- 进程执行时，从一个局部性移动到另一个局部性
- 局部性是一起活跃使用的页面集合
- 程序通常由几个可能重叠的不同局部性组成

**工作集模型 (Working-Set Model)**：
- **工作集窗口 (Working-Set Window)**：固定数量的页面引用（如10,000指令）
- **工作集**：最近Δ页面引用中的页面集合
- 如果页面在活跃使用中，它将在工作集中
- 如果不再使用，在最后引用后Δ时间单位后将从工作集中删除

**工作集策略实施**：
- 设 WS_i 为进程 P_i 的工作集
- D = ΣWS_i = 总需求帧数
- m = 可用帧数
- 如果 D > m → 抖动
- 策略：如果 D > m，暂停一些进程

##### 3. 页错误频率 (Page-Fault Frequency, PFF) 方案
- 建立"可接受的"页错误率
- 如果实际错误率太低，从进程中移除一帧
- 如果实际错误率太高，为进程分配另一帧
- 如果没有空闲帧，暂停进程

### 7.5.3 内存映射文件

#### 传统文件访问的问题
每次文件访问都需要系统调用和磁盘访问，使用标准系统调用：open()、read()、write()

#### 内存映射的概念
通过将磁盘块映射到内存中的页面，将文件I/O当作例程内存访问处理：
- 文件最初使用请求分页读取（到内存中）
- 文件的页大小部分从文件系统读取到物理页面
- 对文件的后续读/写被当作普通内存访问处理

#### 内存映射的优势
- 通过内存而不是read()/write()系统调用处理文件I/O，简化文件访问
- 允许多个进程同时映射同一文件，允许共享内存中的页面

### 7.5.4 内核内存分配

#### 内核内存的特殊性
- 内核内存与用户内存处理方式不同
- 从空闲内存池分配（不同于普通内存）
- 内核请求各种大小的数据结构的内存
- 某些内核内存需要是连续的

#### 内核内存分配策略

##### 1. 伙伴系统 (Buddy System)
**原理**：
- 从由物理连续页面组成的固定大小段分配内存
- 使用2的幂分配器分配内存
- 以2的幂为单位满足请求（4K、8K、16K...）
- 大小不合适的请求被舍入到下一个最高的2的幂

**优点**：
- 相邻伙伴的快速合并形成更大的段

**缺点**：
- 内部碎片

##### 2. 平板分配 (Slab Allocation)
**基本概念**：
- **平板 (Slab)**：一个或多个物理连续的帧
- **缓存 (Cache)**：由一个或多个平板组成
- 每个唯一的内核数据结构有单一缓存

**工作机制**：
- 如果平板装满已使用对象，下一个对象从空平板分配
- 如果没有空平板，分配新平板

**优点**：
- 无碎片
- 快速内存请求满足

## 7.6 分段机制 (Segmentation)

### 7.6.1 分段基本概念

#### 分段的用户视图
分段是支持用户内存视图的内存管理方案。用户程序是段的集合，段是逻辑单元，如：
- 主程序
- 过程、函数、方法、对象
- 局部变量、全局变量
- 公共块
- 栈
- 符号表
- 数组

#### 分段方式
- 由程序员进行
- 由编译器进行

#### 逻辑地址构成
逻辑地址由二元组组成：<段号, 偏移>

### 7.6.2 段表结构

#### 段表的作用
将二维地址映射到一维物理地址。

#### 段表项内容
每个表项包含：
- **基址 (Base)**：段在内存中驻留的起始物理地址
- **限长 (Limit)**：段的长度

#### 地址转换过程
1. 段号s用作段表的索引
2. 偏移d必须在0和段限长之间
3. 如果无效，非法内存访问
4. 如果有效，物理地址 = 基址 + d

### 7.6.3 分段与分页比较

#### 分段的优点
- 符合用户的逻辑视图
- 便于共享和保护
- 段可以动态增长

#### 分段的缺点
- 外部碎片问题
- 段大小不固定，分配复杂

#### 分页的优点
- 无外部碎片
- 分配简单

#### 分页的缺点
- 不符合用户逻辑视图
- 共享和保护较困难