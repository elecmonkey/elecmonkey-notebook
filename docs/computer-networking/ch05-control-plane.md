# 第5章 网络层：控制平面

## 5.1 路由问题与算法分类
### 5.1.1 路由问题的本质
路由（routing）解决“从源到目的走哪条路更好”的问题。路径被抽象为一系列路由器（router）组成的序列，路径“好”通常意味着代价最小、延迟最小或拥塞最小。

### 5.1.2 图模型与链路代价
网络通常被抽象为图 G=(N,E)：
- N：路由器集合
- E：链路集合
- c(x,y)：链路代价，可能与带宽、时延、负载相关

### 5.1.3 路由算法的分类
- 全局（global）：掌握完整拓扑与链路代价，如链路状态（link-state）。
- 分布式（decentralized）：只知道邻居信息，如距离向量（distance-vector）。
- 静态（static）：变化慢，人工配置多。
- 动态（dynamic）：周期或事件驱动更新。

## 5.2 链路状态路由算法（LS Algorithm）
### 5.2.1 算法思想
链路状态（Link State, LS）算法是一种**全局式**路由算法。
*   **全局信息**：每个路由器都拥有整个网络的**完整拓扑结构**和所有链路的代价信息。
*   **信息获取**：通过**链路状态广播**（Link State Broadcast），每个节点向全网发送自己与邻居的链路状态。
*   **计算核心**：每个节点独立运行 **Dijkstra 算法**，计算从自己到所有其他节点的最短路径树（Shortest Path Tree），进而生成转发表。

### 5.2.2 Dijkstra 算法实例
设源节点为 $u$，$D(v)$ 表示从 $u$ 到 $v$ 的当前最短路径代价，$p(v)$ 表示 $v$ 的前驱节点，$N'$ 为已找到最短路径的节点集合。
**步骤**：
1.  **初始化**：$N'=\{u\}$，对于所有 $v$，若 $u,v$ 相邻则 $D(v)=c(u,v)$，否则 $D(v)=\infty$。
2.  **循环**：
    *   在不在 $N'$ 中的节点中，找到 $D(w)$ 最小的节点 $w$。
    *   将 $w$ 加入 $N'$。
    *   **更新邻居**：对于 $w$ 的所有邻居 $v$（且 $v \notin N'$），更新 $D(v) = \min( D(v), D(w) + c(w,v) )$。
3.  **结束**：直到所有节点都在 $N'$ 中。

**实例演示**：
考虑节点 u, x, y, z, w, v。u 为源点。
| 步骤 | N' | D(v), p(v) | D(x), p(x) | D(y), p(y) | D(w), p(w) | D(z), p(z) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | u | 7, u | 5, u | $\infty$ | 3, u | $\infty$ |
| 1 | uw | 6, w | 5, u | 11, w | **3, u** | $\infty$ |
| 2 | uwx | 6, w | **5, u** | 11, w | | 14, x |
| 3 | uwxv | **6, w** | | 11, w | | 14, x |
| 4 | uwxvy | | | **10, y** | | 12, y |
| 5 | uwxvyz | | | | | **12, y** |
*(注：表中数据仅为示意，实际计算需依据具体拓扑图)*

### 5.2.3 路由振荡（Routing Oscillation）
若链路代价与**拥塞程度**（流量）相关，LS 算法可能导致路由振荡。
*   **场景**：路由器总是选择负载最小的路径。
*   **过程**：所有流量涌向低负载路径 $\to$ 该路径变拥塞（代价变大） $\to$ 路由算法重新计算，所有流量切向另一条路径 $\to$ 原路径空闲，新路径拥塞 $\to$ 再次切换。
*   **结果**：流量在两组路径间反复横跳，导致网络不稳定。
*   **解决**：不让所有路由器同时运行算法（引入随机延迟）。

## 5.3 距离矢量路由算法（DV Algorithm）
### 5.3.1 算法思想
距离矢量（Distance Vector, DV）算法是一种**分布式**、**迭代**、**异步**的算法。
*   **局部信息**：每个节点只知道**自己到邻居的代价**，以及**邻居到目的地的距离估计**。
*   **Bellman-Ford 方程**：核心状态方程。
    $$ d_x(y) = \min_v \{ c(x,v) + d_v(y) \} $$
    其中 $d_x(y)$ 是 $x$ 到 $y$ 的最低代价，$v$ 是 $x$ 的邻居。
*   **交互**：节点定期向邻居发送自己的距离向量（Distance Vector）。收到邻居的 DV 后，利用 BF 方程重新计算自己的 DV，若有变化则通知邻居。

### 5.3.2 DV 算法实例
以 3 个节点 x, y, z 为例，链路代价 $c(x,y)=2, c(y,z)=1, c(x,z)=7$。
1.  **初始化**：各节点只知直接邻居代价。$x$ 知道 $D_x=[0, 2, 7]$。
2.  **更新**：
    *   $y$ 计算到 $z$ 的距离：直接是 1。
    *   $x$ 收到 $y$ 的向量（$y$ 到 $z$ 是 1）。
    *   $x$ 更新到 $z$ 的距离：$\min( c(x,z), c(x,y)+d_y(z) ) = \min(7, 2+1) = 3$。
    *   $x$ 的新向量变为 $[0, 2, 3]$，并通告给邻居。

### 5.3.3 路由环路与毒性逆转
DV 算法的一个主要问题是**收敛慢**，且可能产生路由环路。
*   **好消息传得快**：某个链路代价变小，很快传播全网。
*   **坏消息传得慢（无穷计数问题）**：
    *   **场景**：$x-y-z$，若 $x-y$ 链路断开（代价无穷），$y$ 可能误以为可以通过 $z$ 到达 $x$（因为 $z$ 曾告诉 $y$ 它能到 $x$，其实 $z$ 是经过 $y$ 到 $x$ 的）。
    *   **循环**：$y$ 更新路径指向 $z$，$z$ 更新路径指向 $y$，两者距离相互推高，直到无穷大。
*   **毒性逆转（Poisoned Reverse）**：
    *   **机制**：如果 $z$ 是通过 $y$ 到达 $x$ 的，那么 $z$ 在通告给 $y$ 时，必须谎称 $d_z(x) = \infty$。
    *   **作用**：防止 $y$ 误以为 $z$ 有一条独立的路径到达 $x$，从而避免两个节点间的直接路由环路。
    *   **局限**：无法解决涉及 3 个或更多节点的复杂环路。

## 5.4 LS 与 DV 的比较
| 特性 | 链路状态 (LS) | 距离矢量 (DV) |
| :--- | :--- | :--- |
| **报文复杂性** | 高（需向全网广播） | 低（仅与邻居交换） |
| **收敛速度** | 快（$O(n^2)$ 算法，广播快） | 慢（可能遇到无穷计数） |
| **健壮性** | 较好（节点计算错误只影响局部） | 较差（错误会传播全网） |
| **路径计算** | 每个节点拥有完整拓扑 | 仅知道邻居和下一跳 |
| **代表协议** | OSPF, IS-IS | RIP, BGP (Path Vector) |

## 5.4 自治系统与域内/域间路由
### 5.4.1 自治系统（AS）概念
自治系统（Autonomous System, AS）是由单一管理机构控制的一组网络。AS 之间通过网关路由器相连。

### 5.4.2 域内与域间的区别
- 域内路由（intra-AS）：性能优先，协议统一。
- 域间路由（inter-AS）：策略优先，管理控制重要。

### 5.4.3 选择不同协议的原因
- 域内：一个管理者，强调效率
- 域间：多个管理者，强调策略与商业控制

## 5.5 OSPF 域内路由
### 5.5.1 OSPF 特点
OSPF（Open Shortest Path First）：
- 链路状态协议
- 在 IP 上运行
- 支持认证
- 支持多种度量（带宽、时延）

### 5.5.2 OSPF 工作流程
- 路由器洪泛链路状态通告（LSA）
- 每个路由器获得完整拓扑
- 使用 Dijkstra 计算转发表

### 5.5.3 层次化 OSPF
- 划分区域（area）与骨干（backbone）
- 区域内洪泛减少开销
- 边界路由器汇总区域信息

## 5.6 BGP 域间路由
### 5.6.1 BGP 概述
BGP（Border Gateway Protocol）是事实标准的域间路由协议：
- 基于 TCP
- 使用路径向量（path vector）

### 5.6.2 eBGP 与 iBGP
- eBGP：AS 之间交换路由信息
- iBGP：AS 内传播路由信息

### 5.6.3 BGP 路由属性
- AS-PATH：经过的 AS 列表
- NEXT-HOP：下一跳路由器

### 5.6.4 路由选择策略
常见选择规则：
1) 本地偏好（local preference）
2) 最短 AS-PATH
3) 热土豆路由（hot potato）

### 5.6.5 策略驱动
BGP 强调策略控制：AS 可选择是否接受某条路由，是否向外通告。

## 5.7 ICMP 与诊断
### 5.7.1 ICMP 功能
ICMP（Internet Control Message Protocol）用于传递控制与差错信息。

### 5.7.2 ICMP 报文结构
包含 type、code 以及导致错误的数据报前 8 字节。

### 5.7.3 Traceroute
通过递增 TTL 发送探测包，触发路由器返回 ICMP time exceeded 报文，最终目的返回 port unreachable。

## 5.8 IP 组播与 IGMP
### 5.8.1 组播概念
组播（multicast）是一对多传输方式，适用于视频直播、会议等场景。

### 5.8.2 IGMP
IGMP（Internet Group Management Protocol）用于管理组播成员，路由器根据成员信息转发数据。

### 5.8.3 组播注意事项
组播数据报一般不产生 ICMP 差错报文。
